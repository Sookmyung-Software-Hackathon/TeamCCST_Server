"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var constants_1 = require("../constants");
function provide(serviceIdentifier, force) {
    return function (target) {
        var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_1.METADATA_KEY.PARAM_TYPES, target);
        var redecorateWithInject = force === true;
        if (redecorateWithInject === true && isAlreadyDecorated === false) {
            inversify_1.decorate(inversify_1.injectable(), target);
        }
        else if (redecorateWithInject === true && isAlreadyDecorated === true) {
            // Do nothing
        }
        else {
            try {
                inversify_1.decorate(inversify_1.injectable(), target);
            }
            catch (e) {
                throw new Error("Cannot apply @provide decorator multiple times but is has been used " +
                    ("multiple times in " + target.name + " ") +
                    "Please use @provide(ID, true) if you are trying to declare multiple bindings!");
            }
        }
        var currentMetadata = {
            constraint: function (bind, bindTarget) { return bind(serviceIdentifier).to(bindTarget); },
            implementationType: target
        };
        var previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [];
        var newMetadata = [currentMetadata].concat(previousMetadata);
        Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect);
        return target;
    };
}
exports.default = provide;
