define(["require", "exports", "inversify", "../constants"], function (require, exports, inversify_1, constants_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function provide(serviceIdentifier, force) {
        return function (target) {
            var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_1.METADATA_KEY.PARAM_TYPES, target);
            var redecorateWithInject = force === true;
            if (redecorateWithInject === true && isAlreadyDecorated === false) {
                inversify_1.decorate(inversify_1.injectable(), target);
            }
            else if (redecorateWithInject === true && isAlreadyDecorated === true) {
                // Do nothing
            }
            else {
                try {
                    inversify_1.decorate(inversify_1.injectable(), target);
                }
                catch (e) {
                    throw new Error("Cannot apply @provide decorator multiple times but is has been used " +
                        ("multiple times in " + target.name + " ") +
                        "Please use @provide(ID, true) if you are trying to declare multiple bindings!");
                }
            }
            var currentMetadata = {
                constraint: function (bind, bindTarget) { return bind(serviceIdentifier).to(bindTarget); },
                implementationType: target
            };
            var previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [];
            var newMetadata = [currentMetadata].concat(previousMetadata);
            Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect);
            return target;
        };
    }
    exports.default = provide;
});
